	cpu LMM
	.module bsp.c
	.area text(rom, con, rel)
	.dbfile ./bsp.c
	.dbfunc e BSP_init _BSP_init fV
_BSP_init::
	.dbline -1
	.dbline 34
; /*****************************************************************************
; * PELICAN crossing example
; * Last Updated for Version: 1.5.05
; * Date of the Last Update:  Dec 24, 2006
; *
; *                    Q u a n t u m     L e a P s
; *                    ---------------------------
; *                    innovating embedded systems
; *
; * Copyright (C) 2002-2006 Quantum Leaps, LLC. All rights reserved.
; *
; * This software may be distributed and modified under the terms of the GNU
; * General Public License version 2 (GPL) as published by the Free Software
; * Foundation and appearing in the file GPL.TXT included in the packaging of
; * this file. Please note that GPL Section 2[b] requires that all works based
; * on this software must also be made publicly available under the terms of
; * the GPL ("Copyleft").
; *
; * Alternatively, this software may be distributed and modified under the
; * terms of Quantum Leaps commercial licenses, which expressly supersede
; * the GPL and are specifically designed for licensees interested in
; * retaining the proprietary status of their code.
; *
; * Contact information:
; * Quantum Leaps Web site:  http://www.quantum-leaps.com
; * e-mail:                  sales@quantum-leaps.com
; *****************************************************************************/
; #include "qpn_port.h"
; #include "bsp.h"
; #include "qassert.h"
; 
; 
; /*..........................................................................*/
; void BSP_init(void) {
	.dbline 39
; //    LCD_1_Start();                                          /* Init the LCD */
; //    LCD_1_Position(0, 0);
; //    LCD_1_PrCString("Quantum Leaps");
; 
;     LED_1_Start();
	push X
	xcall _LED_1_Start
	.dbline 40
;     LED_2_Start();
	xcall _LED_2_Start
	.dbline 41
;     LED_3_Start();
	xcall _LED_3_Start
	.dbline 42
;     LED_4_Start();
	xcall _LED_4_Start
	pop X
	.dbline -2
	.dbline 43
; }
L1:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e BSP_tick _BSP_tick fV
_BSP_tick::
	.dbline -1
	or F,-64
	push A
	mov A,REG[0xd0]
	push A
	mov A,REG[0xd3]
	push A
	mov A,REG[0xd4]
	push A
	mov A,REG[0xd5]
	push A
	mov REG[0xd0],>__r0
	mov A,[__r0]
	push A
	mov A,[__r1]
	push A
	mov A,[__r2]
	push A
	mov A,[__r3]
	push A
	mov A,[__r4]
	push A
	mov A,[__r5]
	push A
	mov A,[__r6]
	push A
	mov A,[__r7]
	push A
	mov A,[__r8]
	push A
	mov A,[__r9]
	push A
	mov A,[__r10]
	push A
	mov A,[__r11]
	push A
	mov A,[__rX]
	push A
	mov A,[__rY]
	push A
	mov A,[__rZ]
	push A
	.dbline 46
; /*..........................................................................*/
; #pragma interrupt_handler BSP_tick
; void BSP_tick(void) {
	.dbline 47
;     LED_3_Invert();
	push X
	xcall _LED_3_Invert
	pop X
	.dbline 48
;     QF_tick();
	xcall _QF_tick
	.dbline -2
	.dbline 49
; }
L2:
	mov REG[0xD0],>__r0
	pop A
	mov [__rZ],A
	pop A
	mov [__rY],A
	pop A
	mov [__rX],A
	pop A
	mov [__r11],A
	pop A
	mov [__r10],A
	pop A
	mov [__r9],A
	pop A
	mov [__r8],A
	pop A
	mov [__r7],A
	pop A
	mov [__r6],A
	pop A
	mov [__r5],A
	pop A
	mov [__r4],A
	pop A
	mov [__r3],A
	pop A
	mov [__r2],A
	pop A
	mov [__r1],A
	pop A
	mov [__r0],A
	pop A
	mov REG[213],A
	pop A
	mov REG[212],A
	pop A
	mov REG[211],A
	pop A
	mov REG[208],A
	pop A
	.dbline 0 ; func end
	reti
	.dbend
	.dbfunc e QF_start _QF_start fV
_QF_start::
	.dbline -1
	.dbline 51
; /*..........................................................................*/
; void QF_start(void) {
	.dbline 52
;     M8C_EnableGInt;                             /* Enable Global interrupts */
		or  F, 01h

	.dbline 54
; 
;     SleepTimer_1_Start();
	push X
	xcall _SleepTimer_1_Start
	.dbline 55
;     SleepTimer_1_SetInterval(SleepTimer_1_8_HZ);      /* Set interrupt rate */
	mov A,16
	xcall _SleepTimer_1_SetInterval
	.dbline 56
;     SleepTimer_1_EnableInt();
	xcall _SleepTimer_1_EnableInt
	pop X
	.dbline -2
	.dbline 57
; }
L3:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e QF_onIdle _QF_onIdle fV
_QF_onIdle::
	.dbline -1
	.dbline 59
; /*..........................................................................*/
; void QF_onIdle(void) {        /* entered with interrupts LOCKED, see NOTE02 */
	.dbline 60
;     LED_4_On();
	push X
	xcall _LED_4_On
	pop X
	.dbline 66
; 
; #ifdef NDEBUG
;     /* tread-safe transition to the sleep mode */
; #endif
; 
;     QF_INT_UNLOCK();                              /* just unlock interrupts */
		or  F, 01h

	.dbline 67
;     LED_4_Off();
	push X
	xcall _LED_4_Off
	pop X
	.dbline -2
	.dbline 68
; }
L4:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e Q_assert_handler _Q_assert_handler fV
;           line -> X-7
;           file -> X-5
_Q_assert_handler::
	.dbline -1
	push X
	mov X,SP
	.dbline 70
; /*..........................................................................*/
; void Q_assert_handler(char const Q_ROM * const Q_ROM_VAR file, int line) {
	.dbline 71
;     (void)file;                                   /* avoid compiler warning */
	.dbline 72
;     (void)line;                                   /* avoid compiler warning */
	.dbline 73
;     QF_INT_LOCK();            /* make sure that all interrupts are disabled */
		and F, FEh

	.dbline 74
;     LED_1_On();
	push X
	xcall _LED_1_On
	.dbline 75
;     LED_2_On();
	xcall _LED_2_On
	.dbline 76
;     LED_3_On();
	xcall _LED_3_On
	.dbline 77
;     LED_4_On();
	xcall _LED_4_On
	pop X
L6:
	.dbline 80
	.dbline 81
L7:
	.dbline 80
	xjmp L6
X0:
	.dbline -2
	.dbline 82
; //    LCD_1_Position(0, 0);
; //    LCD_1_PrCString(file);
;     while (1) {      /* NOTE: replace the loop with reset for final version */
;     }
; }
L5:
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l line -7 I
	.dbsym l file -5 ppc
	.dbend
