	cpu LMM
	.module qfn.c
	.area lit(rom, con, rel)
_l_this_file:
	.byte 'q,'f,'n,0
	.dbfile ./qfn.c
	.dbsym s l_this_file _l_this_file A[4:4]c
_l_pow2:
	.byte 0,1
	.byte 2,4
	.byte 8,16
	.byte 32,64
	.byte 128
	.dbsym s l_pow2 _l_pow2 A[9:9]c
	.area text(rom, con, rel)
	.dbfile ./qfn.c
	.dbfunc e QF_post _QF_post fV
;             cb -> X+2
;              a -> X+0
;            par -> X-6
;            sig -> X-5
;           prio -> X-4
_QF_post::
	.dbline -1
	push X
	mov X,SP
	add SP,4
	.dbline 87
; /*****************************************************************************
; * Product: QF-nano implemenation
; * Last Updated for Version: 1.5.07
; * Date of the Last Update:  Mar 05, 2007
; *
; *                    Q u a n t u m     L e a P s
; *                    ---------------------------
; *                    innovating embedded systems
; *
; * Copyright (C) 2002-2007 Quantum Leaps, LLC. All rights reserved.
; *
; * This software may be distributed and modified under the terms of the GNU
; * General Public License version 2 (GPL) as published by the Free Software
; * Foundation and appearing in the file GPL.TXT included in the packaging of
; * this file. Please note that GPL Section 2[b] requires that all works based
; * on this software must also be made publicly available under the terms of
; * the GPL ("Copyleft").
; *
; * Alternatively, this software may be distributed and modified under the
; * terms of Quantum Leaps commercial licenses, which expressly supersede
; * the GPL and are specifically designed for licensees interested in
; * retaining the proprietary status of their code.
; *
; * Contact information:
; * Quantum Leaps Web site:  http://www.quantum-leaps.com
; * e-mail:                  sales@quantum-leaps.com
; *****************************************************************************/
; #include "qpn_port.h"                                       /* QP-nano port */
; #include "qassert.h"
; 
; Q_DEFINE_THIS_MODULE(qfn)
; 
; /** \ingroup qfn
; * \file qfn.c
; * QF-nano implementation.
; */
; 
; /* Public-scope objects ----------------------------------------------------*/
; uint8_t QF_readySet_;                               /* ready-set of QF-nano */
; 
; /* local objects -----------------------------------------------------------*/
; static uint8_t const Q_ROM Q_ROM_VAR l_pow2[] = {
;     0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
; };
; 
; /* default macros for accessing data in ROM */
; #ifndef Q_ROM_BYTE
;     /** \brief Macro to access a byte allocated in ROM
;     *
;     * Some compilers for Harvard-architecture MCUs, such as gcc for AVR, do
;     * not generate correct code for accessing data allocated in the program
;     * space (ROM). The workaround for such compilers is to explictly add
;     * assembly code to access each data element allocated in the program
;     * space. The macro Q_ROM_BYTE() retrieves a byte from the given ROM
;     * address.
;     *
;     * The Q_ROM_BYTE() macro should be defined in the qpn_port.h header file
;     * for each compiler that cannot handle correctly data allocated in ROM
;     * (such as the gcc). If the macro is left undefined, the default
;     * definition simply returns the argument and lets the compiler synthesize
;     * the correct code.
;     */
;     #define Q_ROM_BYTE(rom_var_)   (rom_var_)
; #endif
; #ifndef Q_ROM_PTR
;     /** \brief Macro to access a pointer allocated in ROM
;     *
;     * Some compilers for Harvard-architecture MCUs, such as gcc for AVR, do
;     * not generate correct code for accessing data allocated in the program
;     * space (ROM). The workaround for such compilers is to explictly add
;     * assembly code to access each data element allocated in the program
;     * space. The macro Q_ROM_PTR() retrieves an object-pointer from the given
;     * ROM address. Please note that the pointer can be pointing to the object
;     * in RAM or ROM.
;     *
;     * The Q_ROM_PTR() macro should be defined in the qpn_port.h header file
;     * for each compiler that cannot handle correctly data allocated in ROM
;     * (such as the gcc). If the macro is left undefined, the default
;     * definition simply returns the argument and lets the compiler synthesize
;     * the correct code.
;     */
;     #define Q_ROM_PTR(rom_var_)    (rom_var_)
; #endif
; 
; /*..........................................................................*/
; #if (Q_PARAM_SIZE != 0)
; void QF_post(uint8_t prio, QSignal sig, QParam par) Q_REENTRANT {
	.dbline 94
; #else
; void QF_post(uint8_t prio, QSignal sig) Q_REENTRANT {
; #endif
;     QActiveCB const Q_ROM * Q_ROM_VAR cb;
;     QActive *a;
; 
;     QF_INT_LOCK();
		and F, FEh

	.dbline 95
;     cb = &QF_active[prio];
	mov REG[0xd0],>__r0
	mov A,[X-4]
	mov [__r1],A
	mov [__r0],0
	mov [__r3],5
	mov [__r2],0
	mov [__rX],0
	mov [__rY],0
X0:
	cmp [__r2],0
	jnz X3
	cmp [__r3],0
	jz X2
X3:
	and F,-5
	rrc [__r2]
	rrc [__r3]
	jnc X1
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add [__rX],A
	mov A,[__r0]
	adc [__rY],A
X1:
	asl [__r1]
	rlc [__r0]
	jmp X0
X2:
	mov [__r1],[__rX]
	mov [__r0],[__rY]
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add A,<_QF_active
	mov [X+3],A
	mov A,[__r0]
	adc A,>_QF_active
	mov [X+2],A
	.dbline 96
;     a = (QActive *)Q_ROM_PTR(cb->act__);
	mov A,[X+3]
	mov [__r1],A
	mov A,[X+2]
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	pop X
	mov [X+1],A
	mov A,[__r0]
	mov [X+0],A
	.dbline 98
; 
;     if (a->nUsed__ == (uint8_t)0) {
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r1]
	cmp A,0
	jnz L2
	.dbline 98
	.dbline 99
;         ++a->nUsed__;                            /* update number of events */
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 101
; 
;         Q_SIG(a) = sig;                       /* deliver the event directly */
	mov A,[X+1]
	mov [__r1],A
	mov A,[X+0]
	mov REG[0xd5],A
	mov A,[X-5]
	mvi [__r1],A
	.dbline 103
; #if (Q_PARAM_SIZE != 0)
;         Q_PAR(a) = par;
	mov A,[X+1]
	add A,1
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd5],A
	mov A,[X-6]
	mvi [__r1],A
	.dbline 105
; #endif
;         QF_readySet_ |= Q_ROM_BYTE(l_pow2[prio]);      /* set the ready bit */
	mov A,[X-4]
	mov [__r1],A
	mov [__r0],0
	add [__r1],<_l_pow2
	adc [__r0],>_l_pow2
	mov A,[__r0]
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov REG[0xd0],>_QF_readySet_
	mov A,[_QF_readySet_]
	mov REG[0xd0],>__r0
	or A,[__r0]
	mov REG[0xd0],>_QF_readySet_
	mov [_QF_readySet_],A
	.dbline 110
; 
; #ifdef QK_PREEMPTIVE
;         QK_schedule();                  /* check for synchronous preemption */
; #endif
;     }
	xjmp L3
L2:
	.dbline 111
;     else {
	.dbline 113
	mov REG[0xd0],>__r0
	mov A,[X+3]
	add A,4
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov A,[X+1]
	add A,6
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r2],A
	mov A,[__r0]
	cmp A,[__r2]
	jc L4
X4:
	.dbline 113
	.dbline 113
	xjmp L5
L4:
	.dbline 113
;             /* the queue must be able to accept the event (cannot overflow) */
;         Q_ASSERT(a->nUsed__ <= Q_ROM_BYTE(cb->end__));
	mov A,0
	push A
	mov A,113
	push A
	mov A,>_l_this_file
	push A
	mov A,<_l_this_file
	push A
	xcall _Q_assert_handler
	add SP,-4
L5:
	.dbline 114
;         ++a->nUsed__;                            /* update number of events */
	mov REG[0xd0],>__r0
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 116
;                                 /* insert event into the ring buffer (FIFO) */
;         ((QEvent *)Q_ROM_PTR(cb->queue__))[a->head__].sig = sig;
	mov A,[X+3]
	add A,2
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	mov [__r1],A
	pop X
	mov A,[X+1]
	add A,4
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r3],A
	mov [__r2],0
	asl [__r3]
	rlc [__r2]
	mov A,[__r3]
	add A,[__r1]
	mov [__r1],A
	mov A,[__r2]
	adc A,[__r0]
	mov REG[0xd5],A
	mov A,[X-5]
	mvi [__r1],A
	.dbline 118
; #if (Q_PARAM_SIZE != 0)
;         ((QEvent *)Q_ROM_PTR(cb->queue__))[a->head__].par = par;
	mov A,[X+3]
	add A,2
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	mov [__r1],A
	pop X
	mov A,[X+1]
	add A,4
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r3],A
	mov [__r2],0
	asl [__r3]
	rlc [__r2]
	mov A,[__r3]
	add A,[__r1]
	mov [__r1],A
	mov A,[__r2]
	adc A,[__r0]
	mov [__r0],A
	add [__r1],1
	adc [__r0],0
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[X-6]
	mvi [__r1],A
	.dbline 120
; #endif
;         ++a->head__;
	mov A,[X+1]
	add A,4
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 121
;         if (a->head__ == Q_ROM_BYTE(cb->end__)) {
	mov A,[X+3]
	add A,4
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov A,[X+1]
	add A,4
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	cmp A,[__r0]
	jnz L6
	.dbline 121
	.dbline 122
;             a->head__ = (uint8_t)0;                        /* wrap the head */
	mov A,[X+1]
	add A,4
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd5],A
	mov A,0
	mvi [__r1],A
	.dbline 123
;         }
L6:
	.dbline 124
;     }
L3:
	.dbline 125
;     QF_INT_UNLOCK();
		or  F, 01h

	.dbline -2
	.dbline 126
; }
L1:
	add SP,-4
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l cb 2 pX
	.dbsym l a 0 pX
	.dbsym l par -6 c
	.dbsym l sig -5 c
	.dbsym l prio -4 c
	.dbend
	.dbfunc e QF_postISR _QF_postISR fV
;             cb -> X+2
;              a -> X+0
;            par -> X-6
;            sig -> X-5
;           prio -> X-4
_QF_postISR::
	.dbline -1
	push X
	mov X,SP
	add SP,4
	.dbline 133
; /*..........................................................................*/
; #if (Q_PARAM_SIZE != 0)
; void QF_postISR(uint8_t prio, QSignal sig, QParam par) Q_REENTRANT
; #else
; void QF_postISR(uint8_t prio, QSignal sig) Q_REENTRANT
; #endif
; {
	.dbline 145
;     QActiveCB const Q_ROM * Q_ROM_VAR cb;
;     QActive *a;
; 
; #ifdef QF_ISR_NEST
; #ifdef QF_ISR_KEY_TYPE
;     QF_ISR_KEY_TYPE key;
;     QF_ISR_LOCK(key);
; #else
;     QF_INT_LOCK();
; #endif
; #endif
;     cb = &QF_active[prio];
	mov REG[0xd0],>__r0
	mov A,[X-4]
	mov [__r1],A
	mov [__r0],0
	mov [__r3],5
	mov [__r2],0
	mov [__rX],0
	mov [__rY],0
X5:
	cmp [__r2],0
	jnz X8
	cmp [__r3],0
	jz X7
X8:
	and F,-5
	rrc [__r2]
	rrc [__r3]
	jnc X6
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add [__rX],A
	mov A,[__r0]
	adc [__rY],A
X6:
	asl [__r1]
	rlc [__r0]
	jmp X5
X7:
	mov [__r1],[__rX]
	mov [__r0],[__rY]
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add A,<_QF_active
	mov [X+3],A
	mov A,[__r0]
	adc A,>_QF_active
	mov [X+2],A
	.dbline 146
;     a = (QActive *)Q_ROM_PTR(cb->act__);
	mov A,[X+3]
	mov [__r1],A
	mov A,[X+2]
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	pop X
	mov [X+1],A
	mov A,[__r0]
	mov [X+0],A
	.dbline 148
; 
;     if (a->nUsed__ == (uint8_t)0) {
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r1]
	cmp A,0
	jnz L9
	.dbline 148
	.dbline 149
;         ++a->nUsed__;                            /* update number of events */
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 151
; 
;         Q_SIG(a) = sig;                       /* deliver the event directly */
	mov A,[X+1]
	mov [__r1],A
	mov A,[X+0]
	mov REG[0xd5],A
	mov A,[X-5]
	mvi [__r1],A
	.dbline 153
; #if (Q_PARAM_SIZE != 0)
;         Q_PAR(a) = par;
	mov A,[X+1]
	add A,1
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd5],A
	mov A,[X-6]
	mvi [__r1],A
	.dbline 155
; #endif
;         QF_readySet_ |= Q_ROM_BYTE(l_pow2[prio]);      /* set the ready bit */
	mov A,[X-4]
	mov [__r1],A
	mov [__r0],0
	add [__r1],<_l_pow2
	adc [__r0],>_l_pow2
	mov A,[__r0]
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov REG[0xd0],>_QF_readySet_
	mov A,[_QF_readySet_]
	mov REG[0xd0],>__r0
	or A,[__r0]
	mov REG[0xd0],>_QF_readySet_
	mov [_QF_readySet_],A
	.dbline 156
;     }
	xjmp L10
L9:
	.dbline 157
;     else {
	.dbline 159
	mov REG[0xd0],>__r0
	mov A,[X+3]
	add A,4
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov A,[X+1]
	add A,6
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r2],A
	mov A,[__r0]
	cmp A,[__r2]
	jc L11
X9:
	.dbline 159
	.dbline 159
	xjmp L12
L11:
	.dbline 159
;             /* the queue must be able to accept the event (cannot overflow) */
;         Q_ASSERT(a->nUsed__ <= Q_ROM_BYTE(cb->end__));
	mov A,0
	push A
	mov A,-97
	push A
	mov A,>_l_this_file
	push A
	mov A,<_l_this_file
	push A
	xcall _Q_assert_handler
	add SP,-4
L12:
	.dbline 160
;         ++a->nUsed__;                            /* update number of events */
	mov REG[0xd0],>__r0
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 162
;                                 /* insert event into the ring buffer (FIFO) */
;         ((QEvent *)Q_ROM_PTR(cb->queue__))[a->head__].sig = sig;
	mov A,[X+3]
	add A,2
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	mov [__r1],A
	pop X
	mov A,[X+1]
	add A,4
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r3],A
	mov [__r2],0
	asl [__r3]
	rlc [__r2]
	mov A,[__r3]
	add A,[__r1]
	mov [__r1],A
	mov A,[__r2]
	adc A,[__r0]
	mov REG[0xd5],A
	mov A,[X-5]
	mvi [__r1],A
	.dbline 164
; #if (Q_PARAM_SIZE != 0)
;         ((QEvent *)Q_ROM_PTR(cb->queue__))[a->head__].par = par;
	mov A,[X+3]
	add A,2
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	mov [__r1],A
	pop X
	mov A,[X+1]
	add A,4
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r3],A
	mov [__r2],0
	asl [__r3]
	rlc [__r2]
	mov A,[__r3]
	add A,[__r1]
	mov [__r1],A
	mov A,[__r2]
	adc A,[__r0]
	mov [__r0],A
	add [__r1],1
	adc [__r0],0
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[X-6]
	mvi [__r1],A
	.dbline 166
; #endif
;         ++a->head__;
	mov A,[X+1]
	add A,4
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 167
;         if (a->head__ == Q_ROM_BYTE(cb->end__)) {
	mov A,[X+3]
	add A,4
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov A,[X+1]
	add A,4
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	cmp A,[__r0]
	jnz L13
	.dbline 167
	.dbline 168
;             a->head__ = (uint8_t)0;                        /* wrap the head */
	mov A,[X+1]
	add A,4
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd5],A
	mov A,0
	mvi [__r1],A
	.dbline 169
;         }
L13:
	.dbline 170
L10:
	.dbline -2
	.dbline 179
;     }
; 
; #ifdef QF_ISR_NEST
; #ifdef QF_ISR_KEY_TYPE
;     QF_ISR_UNLOCK(key);
; #else
;     QF_INT_UNLOCK();
; #endif
; #endif
; }
L8:
	add SP,-4
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l cb 2 pX
	.dbsym l a 0 pX
	.dbsym l par -6 c
	.dbsym l sig -5 c
	.dbsym l prio -4 c
	.dbend
	.dbfunc e QActive_arm _QActive_arm fV
;           tout -> X-7
;             me -> X-5
_QActive_arm::
	.dbline -1
	push X
	mov X,SP
	.dbline 186
; 
; /*--------------------------------------------------------------------------*/
; #if (QF_TIMEEVT_CTR_SIZE != 0)
; 
; #if (QF_TIMEEVT_CTR_SIZE > 1)
; /*..........................................................................*/
; void QActive_arm(QActive *me, QTimeEvtCtr tout) Q_REENTRANT {
	.dbline 187
;     QF_INT_LOCK();
		and F, FEh

	.dbline 188
;     me->tickCtr__ = tout;
	mov REG[0xd0],>__r0
	mov A,[X-4]
	add A,7
	mov [__r1],A
	mov A,[X-5]
	adc A,0
	mov REG[0xd5],A
	mov A,[X-7]
	mvi [__r1],A
	mov A,[X-6]
	mvi [__r1],A
	.dbline 189
;     QF_INT_UNLOCK();
		or  F, 01h

	.dbline -2
	.dbline 190
; }
L15:
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l tout -7 i
	.dbsym l me -5 pX
	.dbend
	.dbfunc e QActive_disarm _QActive_disarm fV
;             me -> X-5
_QActive_disarm::
	.dbline -1
	push X
	mov X,SP
	.dbline 192
; /*..........................................................................*/
; void QActive_disarm(QActive *me) Q_REENTRANT {
	.dbline 193
;     QF_INT_LOCK();
		and F, FEh

	.dbline 194
;     me->tickCtr__ = (QTimeEvtCtr)0;
	mov REG[0xd0],>__r0
	mov A,[X-4]
	add A,7
	mov [__r1],A
	mov A,[X-5]
	adc A,0
	mov REG[0xd5],A
	mov A,0
	mvi [__r1],A
	mvi [__r1],A
	.dbline 195
;     QF_INT_UNLOCK();
		or  F, 01h

	.dbline -2
	.dbline 196
; }
L16:
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l me -5 pX
	.dbend
	.dbfunc e QF_tick _QF_tick fV
;              a -> X+1
;              p -> X+0
_QF_tick::
	.dbline -1
	push X
	mov X,SP
	add SP,3
	.dbline 200
; #endif                                     /* #if (QF_TIMEEVT_CTR_SIZE > 1) */
; 
; /*..........................................................................*/
; void QF_tick(void) {
	.dbline 201
;     uint8_t p = Q_ROM_BYTE(QF_activeNum);
	mov A,>_QF_activeNum
	push X
	mov X,<_QF_activeNum
	romx
	pop X
	mov [X+0],A
L18:
	.dbline 202
;     do {
	.dbline 203
;         QActive *a = (QActive *)Q_ROM_PTR(QF_active[p].act__);
	mov REG[0xd0],>__r0
	mov A,[X+0]
	mov [__r1],A
	mov [__r0],0
	mov [__r3],5
	mov [__r2],0
	mov [__rX],0
	mov [__rY],0
X10:
	cmp [__r2],0
	jnz X13
	cmp [__r3],0
	jz X12
X13:
	and F,-5
	rrc [__r2]
	rrc [__r3]
	jnc X11
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add [__rX],A
	mov A,[__r0]
	adc [__rY],A
X11:
	asl [__r1]
	rlc [__r0]
	jmp X10
X12:
	mov [__r1],[__rX]
	mov [__r0],[__rY]
	mov REG[0xd0],>__r0
	add [__r1],<_QF_active
	adc [__r0],>_QF_active
	mov A,[__r0]
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	pop X
	mov [X+2],A
	mov A,[__r0]
	mov [X+1],A
	.dbline 204
;         if (a->tickCtr__ != (QTimeEvtCtr)0) {
	mov A,[X+2]
	add A,7
	mov [__r1],A
	mov A,[X+1]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r1]
	mov [__r0],A
	mvi A,[__r1]
	cmp [__r0],0
	jnz X14
	cmp A,0
	jz L21
X14:
	.dbline 204
	.dbline 205
;             if ((--a->tickCtr__) == (QTimeEvtCtr)0) {
	mov REG[0xd0],>__r0
	mov A,[X+2]
	add A,7
	mov [__r1],A
	mov A,[X+1]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	mov [__r2],A
	mvi A,[__r1]
	sub [__r1],2
	mov [__r3],A
	sub [__r3],1
	sbb [__r2],0
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	mov A,[__r3]
	mvi [__r1],A
	cmp [__r2],0
	jnz L23
	cmp [__r3],0
	jnz L23
X15:
	.dbline 205
	.dbline 207
; #if (Q_PARAM_SIZE != 0)
;                 QF_postISR(p, (QSignal)Q_TIMEOUT_SIG, (QParam)0);
	mov A,0
	push A
	mov A,4
	push A
	mov A,[X+0]
	push A
	xcall _QF_postISR
	add SP,-3
	.dbline 211
; #else
;                 QF_postISR(p, (QSignal)Q_TIMEOUT_SIG);
; #endif
;             }
L23:
	.dbline 212
;         }
L21:
	.dbline 213
L19:
	.dbline 213
;     } while ((--p) != (uint8_t)0);
	mov REG[0xd0],>__r0
	mov A,[X+0]
	sub A,1
	mov [X+0],A
	cmp A,0
	jnz L18
	.dbline -2
	.dbline 214
; }
L17:
	add SP,-3
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l a 1 pX
	.dbsym l p 0 c
	.dbend
	.area lit(rom, con, rel)
L26:
	.byte 0,1
	.byte 2,2
	.byte 3,3
	.byte 3,3
	.byte 4,4
	.byte 4,4
	.byte 4,4
	.byte 4,4
L27:
	.byte 255,254
	.byte 253,251
	.byte 247,239
	.byte 223,191
	.byte 127
	.area text(rom, con, rel)
	.dbfile ./qfn.c
	.dbfunc e QF_run _QF_run fV
	.dbsym s invPow2 L27 A[9:9]c
	.dbsym s log2Lkup L26 A[16:16]c
;              p -> X+4
;             cb -> X+2
;              a -> X+0
_QF_run::
	.dbline -1
	push X
	mov X,SP
	add SP,5
	.dbline 221
; 
; #endif                                    /* #if (QF_TIMEEVT_CTR_SIZE != 0) */
; 
; /*--------------------------------------------------------------------------*/
; #ifndef QK_PREEMPTIVE
; 
; void QF_run(void) {
	.dbline 229
;     static uint8_t const Q_ROM Q_ROM_VAR log2Lkup[] = {
;         0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4
;     };
;     static uint8_t const Q_ROM Q_ROM_VAR invPow2[] = {
;         0xFF, 0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F
;     };
; 
;     QF_INT_LOCK();
		and F, FEh

	.dbline 231
;     /* all registered active objects have initialization event in the queue */
;     QF_readySet_ = (uint8_t)(~(~0U << Q_ROM_BYTE(QF_activeNum)));
	mov REG[0xd0],>__r0
	mov A,>_QF_activeNum
	push X
	mov X,<_QF_activeNum
	romx
	pop X
	mov [__r2],-1
	jz X17
X18:
	mov REG[0xd0],>__r0
	asl [__r2]
	dec A
	jnz X18
X17:
	mov REG[0xd0],>__r0
	mov A,[__r2]
	cpl A
	mov REG[0xd0],>_QF_readySet_
	mov [_QF_readySet_],A
	.dbline 232
;     QF_INT_UNLOCK();
		or  F, 01h

	.dbline 234
; 
;     QF_start();                                              /* enable ISRs */
	xcall _QF_start
	.dbline 236
; 
;     QF_INT_LOCK();
		and F, FEh

	.dbline 237
L28:
	.dbline 237
;     for (;;) {                                       /* the background loop */
	.dbline 238
;         if (QF_readySet_ != (uint8_t)0) {
	mov REG[0xd0],>_QF_readySet_
	cmp [_QF_readySet_],0
	jz L32
	.dbline 238
	.dbline 244
;             QActiveCB const Q_ROM * Q_ROM_VAR cb;
;             uint8_t p;
;             QActive *a;
; 
; #if (QF_MAX_ACTIVE > 4)
;             if ((QF_readySet_ & 0xF0) != 0U) {        /* upper nibble used? */
	mov A,[_QF_readySet_]
	and A,-16
	cmp A,0
	jz L34
	.dbline 244
	.dbline 245
;                 p = (uint8_t)(Q_ROM_BYTE(log2Lkup[QF_readySet_ >> 4]) + 4);
	mov A,[_QF_readySet_]
	mov REG[0xd0],>__r0
	mov [__r1],A
	mov [__r0],0
	asr [__r0]
	rrc [__r1]
	asr [__r0]
	rrc [__r1]
	asr [__r0]
	rrc [__r1]
	asr [__r0]
	rrc [__r1]
	add [__r1],<L26
	adc [__r0],>L26
	mov A,[__r0]
	push X
	mov X,[__r1]
	romx
	pop X
	add A,4
	mov [X+4],A
	.dbline 246
;             }
	xjmp L35
L34:
	.dbline 249
;             else                    /* upper nibble of QF_readySet_ is zero */
; #endif
;             {
	.dbline 250
;                 p = Q_ROM_BYTE(log2Lkup[QF_readySet_]);
	mov REG[0xd0],>_QF_readySet_
	mov A,[_QF_readySet_]
	mov REG[0xd0],>__r0
	mov [__r1],A
	mov [__r0],0
	add [__r1],<L26
	adc [__r0],>L26
	mov A,[__r0]
	push X
	mov X,[__r1]
	romx
	pop X
	mov [X+4],A
	.dbline 251
;             }
L35:
	.dbline 252
;             QF_INT_UNLOCK();
		or  F, 01h

	.dbline 254
; 
;             cb = &QF_active[p];
	mov REG[0xd0],>__r0
	mov A,[X+4]
	mov [__r1],A
	mov [__r0],0
	mov [__r3],5
	mov [__r2],0
	mov [__rX],0
	mov [__rY],0
X19:
	cmp [__r2],0
	jnz X22
	cmp [__r3],0
	jz X21
X22:
	and F,-5
	rrc [__r2]
	rrc [__r3]
	jnc X20
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add [__rX],A
	mov A,[__r0]
	adc [__rY],A
X20:
	asl [__r1]
	rlc [__r0]
	jmp X19
X21:
	mov [__r1],[__rX]
	mov [__r0],[__rY]
	mov REG[0xd0],>__r0
	mov A,[__r1]
	add A,<_QF_active
	mov [X+3],A
	mov A,[__r0]
	adc A,>_QF_active
	mov [X+2],A
	.dbline 255
;             a = (QActive *)Q_ROM_PTR(cb->act__);
	mov A,[X+3]
	mov [__r1],A
	mov A,[X+2]
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	pop X
	mov [X+1],A
	mov A,[__r0]
	mov [X+0],A
	.dbline 260
; 
; #if (!defined(QF_FSM_ACTIVE) && !defined(Q_NHSM))
;             QHsm_dispatch((QHsm *)a);          /* dispatch to state machine */
; #else
;             QFsm_dispatch((QFsm *)a);          /* dispatch to state machine */
	mov A,[X+0]
	push A
	mov A,[X+1]
	push A
	xcall _QFsm_dispatch
	add SP,-2
	.dbline 263
; #endif
; 
;             QF_INT_LOCK();
		and F, FEh

	.dbline 264
;             if ((--a->nUsed__) == (uint8_t)0) {    /* queue becoming empty? */
	mov REG[0xd0],>__r0
	mov A,[X+1]
	add A,6
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	sub [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	cmp [__r2],0
	jnz L36
	.dbline 264
	.dbline 265
;                 QF_readySet_ &= Q_ROM_BYTE(invPow2[p]);  /* clear ready bit */
	mov A,[X+4]
	mov [__r1],A
	mov [__r0],0
	add [__r1],<L27
	adc [__r0],>L27
	mov A,[__r0]
	push X
	mov X,[__r1]
	romx
	pop X
	mov REG[0xd0],>_QF_readySet_
	and [_QF_readySet_],A
	.dbline 266
;             }
	xjmp L28
L36:
	.dbline 267
;             else {
	.dbline 268
;                 Q_SIG(a) = ((QEvent *)Q_ROM_PTR(cb->queue__))[a->tail__].sig;
	mov REG[0xd0],>__r0
	mov A,[X+3]
	add A,2
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	mov [__r1],A
	pop X
	mov A,[X+1]
	add A,5
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r3],A
	mov [__r2],0
	asl [__r3]
	rlc [__r2]
	mov A,[__r3]
	add A,[__r1]
	mov [__r1],A
	mov A,[__r2]
	adc A,[__r0]
	mov REG[0xd4],A
	mvi A,[__r1]
	mov [__r0],A
	mov A,[X+1]
	mov [__r3],A
	mov A,[X+0]
	mov REG[0xd5],A
	mov A,[__r0]
	mvi [__r3],A
	.dbline 270
; #if (Q_PARAM_SIZE != 0)
;                 Q_PAR(a) = ((QEvent *)Q_ROM_PTR(cb->queue__))[a->tail__].par;
	mov A,[X+3]
	add A,2
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	push A
	mov X,[__r1]
	romx
	mov [__r0],A
	pop A
	inc X
	adc A,0
	romx
	mov [__r1],A
	pop X
	mov A,[X+1]
	add A,5
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	mov [__r3],A
	mov [__r2],0
	asl [__r3]
	rlc [__r2]
	mov A,[__r3]
	add A,[__r1]
	mov [__r1],A
	mov A,[__r2]
	adc A,[__r0]
	mov [__r0],A
	add [__r1],1
	adc [__r0],0
	mov A,[__r0]
	mov REG[0xd4],A
	mvi A,[__r1]
	mov [__r0],A
	mov A,[X+1]
	add A,1
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd5],A
	mov A,[__r0]
	mvi [__r3],A
	.dbline 272
; #endif
;                 ++a->tail__;
	mov A,[X+1]
	add A,5
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov [__r0],A
	mov REG[0xd4],A
	mvi A,[__r1]
	dec [__r1]
	mov [__r2],A
	add [__r2],1
	mov A,[__r0]
	mov REG[0xd5],A
	mov A,[__r2]
	mvi [__r1],A
	.dbline 273
;                 if (a->tail__ == Q_ROM_BYTE(cb->end__)) {   /* wrap around? */
	mov A,[X+3]
	add A,4
	mov [__r1],A
	mov A,[X+2]
	adc A,0
	push X
	mov X,[__r1]
	romx
	pop X
	mov [__r0],A
	mov A,[X+1]
	add A,5
	mov [__r3],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd4],A
	mvi A,[__r3]
	cmp A,[__r0]
	jnz L28
	.dbline 273
	.dbline 274
;                     a->tail__ = (uint8_t)0;                /* wrap the tail */
	mov A,[X+1]
	add A,5
	mov [__r1],A
	mov A,[X+0]
	adc A,0
	mov REG[0xd5],A
	mov A,0
	mvi [__r1],A
	.dbline 275
;                 }
	.dbline 276
;             }
	.dbline 277
;         }
	xjmp L28
L32:
	.dbline 278
	.dbline 279
	xcall _QF_onIdle
	.dbline 280
		and F, FEh

	.dbline 281
	.dbline 282
	.dbline 237
	.dbline 237
	xjmp L28
X16:
	.dbline -2
L25:
	add SP,-5
	pop X
	.dbline 0 ; func end
	ret
	.dbsym l p 4 c
	.dbsym l cb 2 pX
	.dbsym l a 0 pX
	.dbend
	.area data(ram, con, rel)
	.dbfile ./qfn.c
_QF_readySet_::
	.byte 0
	.dbsym e QF_readySet_ _QF_readySet_ c
